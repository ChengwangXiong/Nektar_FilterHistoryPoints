
\chapter{Library Utilities -- {\em LibUtilities}}

Notes on the NekMatrix parameters.

For BlockMatrices, the form (triangular, full, diagonal) indicates the expected form of the lowest 
level data, not the form of the individual blocks.


\section{Expression Templates}

This is currently just a section of notes that will need
to be fleshed out.


Howto enable expression templates for your types.

1.  For a given expression R = A op B, create the following methods
(if they are applicable):

R NekAdd(A, B);
R NekSubtract(A, B);
R NekDivide(A, B);
R NekMultiply(A, B);

Also define the following methods.  

void NekAdd(R, A, B);
void NekSubtract(R, A, B);
void NekDivide(R, A, B);
void NekMultiply(R, A, B);

These methods add into pre-allocated memory R.  
A good practice to code the first set of methods so they call 
the second.


If, for a given type A, A op A is defined, then you must define 
the appropriate opEqual as well:

void NekAddEqual(R, A);
void NekSubtractEqual(R, A);
void NekDivideEqual(R, A);
void NekMultiplyEqual(R, A);


In some cases, optimal processing requires a little extra work.  For example, consider the following expression of matrices:

A + (B*C)

We can avoid temporaries by evaluating B*C first, then adding A.  This works because + is commutative.  However, in teh following:

A - (B*C)

We no longer can avoid a temporary unless you define an operation 

NekLhsMinusEqual

Which takes an accumulator on the right hand side and the left hand side argument.  In the case of a matrix, the code would look something like this:

for(i = 0; i < rows; ++i)
{
  for(j = 0; j < rows; ++j)
  {
    result(i,j) = -result(i,j) + A(i,j);
  }
}

And we can now avoid a temporary.

YOu must tell the expression template library that you have implemented such a method via the HasOpEqualTraits class.  Specialize it as follows:

template<>
class HasLeftOpEqualTraits<NekMatrix, NekMatrix, SubtractOp>
{
   public:
      const static bool Value = true;
};