////////////////////////////////////////////////////////////////////////////////
//
//  File: InputGmsh.cpp
//
//  For more information, please see: http://www.nektar.info/
//
//  The MIT License
//
//  Copyright (c) 2006 Division of Applied Mathematics, Brown University (USA),
//  Department of Aeronautics, Imperial College London (UK), and Scientific
//  Computing and Imaging Institute, University of Utah (USA).
//
//  License for the specific language governing rights and limitations under
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included
//  in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//
//  Description: GMSH converter.
//
////////////////////////////////////////////////////////////////////////////////

#include <string>
#include <fstream>
#include <iostream>
using namespace std;

#include "MeshElements.h"
#include "InputGmsh.h"

namespace Nektar
{
    namespace Utilities
    {
        ModuleKey InputGmsh::className = 
            GetModuleFactory().RegisterCreatorFunction(
                ModuleKey("msh", eInputModule), InputGmsh::create);

        /**
         * @brief Set up InputGmsh object.
         *
         * This function primarily populates the element mapping #elmMap,
         * which takes a msh ID used by Gmsh and translates to element type,
         * element order and whether the element is incomplete (i.e. whether
         * it contains solely boundary nodes, or just face nodes). Note that
         * some of these elements, such as prisms of order >= 3, cannot yet be
         * generated by Gmsh.
         */
        InputGmsh::InputGmsh(MeshSharedPtr m) : InputModule(m)
        {
            //                       Elmt type,   order,  face, volume
            elmMap[  1] = ElmtConfig(eLine,           1,  true, false);
            elmMap[  2] = ElmtConfig(eTriangle,       1,  true, false);
            elmMap[  3] = ElmtConfig(eQuadrilateral,  1,  true, false);
            elmMap[  4] = ElmtConfig(eTetrahedron,    1,  true, false);
            elmMap[  5] = ElmtConfig(eHexahedron,     1,  true, false);
            elmMap[  6] = ElmtConfig(ePrism,          1,  true, false);
            elmMap[  8] = ElmtConfig(eLine,           2,  true, false);
            elmMap[  9] = ElmtConfig(eTriangle,       2,  true, false);
            elmMap[ 10] = ElmtConfig(eQuadrilateral,  2,  true, false);
            elmMap[ 11] = ElmtConfig(eTetrahedron,    2, false, false);
            elmMap[ 12] = ElmtConfig(eHexahedron,     2,  true,  true);
            elmMap[ 13] = ElmtConfig(ePrism,          2,  true, false);
            elmMap[ 15] = ElmtConfig(ePoint,          1,  true, false);
            elmMap[ 16] = ElmtConfig(eQuadrilateral,  2, false, false);
            elmMap[ 17] = ElmtConfig(eHexahedron,     2, false, false);
            elmMap[ 18] = ElmtConfig(ePrism,          2, false, false);
            elmMap[ 20] = ElmtConfig(eTriangle,       3, false, false);
            elmMap[ 21] = ElmtConfig(eTriangle,       3,  true, false);
            elmMap[ 22] = ElmtConfig(eTriangle,       4, false, false);
            elmMap[ 23] = ElmtConfig(eTriangle,       4,  true, false);
            elmMap[ 24] = ElmtConfig(eTriangle,       5, false, false);
            elmMap[ 25] = ElmtConfig(eTriangle,       5,  true, false);
            elmMap[ 26] = ElmtConfig(eLine,           3,  true, false);
            elmMap[ 27] = ElmtConfig(eLine,           4,  true, false);
            elmMap[ 28] = ElmtConfig(eLine,           5,  true, false);
            elmMap[ 29] = ElmtConfig(eTetrahedron,    3,  true,  true);
            elmMap[ 30] = ElmtConfig(eTetrahedron,    4,  true,  true);
            elmMap[ 31] = ElmtConfig(eTetrahedron,    5,  true,  true);
            elmMap[ 32] = ElmtConfig(eTetrahedron,    4,  true, false);
            elmMap[ 33] = ElmtConfig(eTetrahedron,    5,  true, false);
            elmMap[ 36] = ElmtConfig(eQuadrilateral,  3,  true, false);
            elmMap[ 37] = ElmtConfig(eQuadrilateral,  4,  true, false);
            elmMap[ 38] = ElmtConfig(eQuadrilateral,  5,  true, false);
            elmMap[ 39] = ElmtConfig(eQuadrilateral,  3, false, false);
            elmMap[ 40] = ElmtConfig(eQuadrilateral,  4, false, false);
            elmMap[ 41] = ElmtConfig(eQuadrilateral,  5, false, false);
            elmMap[ 42] = ElmtConfig(eTriangle,       6,  true, false);
            elmMap[ 43] = ElmtConfig(eTriangle,       7,  true, false);
            elmMap[ 44] = ElmtConfig(eTriangle,       8,  true, false);
            elmMap[ 45] = ElmtConfig(eTriangle,       9,  true, false);
            elmMap[ 46] = ElmtConfig(eTriangle,      10,  true, false);
            elmMap[ 47] = ElmtConfig(eQuadrilateral,  6,  true, false);
            elmMap[ 48] = ElmtConfig(eQuadrilateral,  7,  true, false);
            elmMap[ 49] = ElmtConfig(eQuadrilateral,  8,  true, false);
            elmMap[ 50] = ElmtConfig(eQuadrilateral,  9,  true, false);
            elmMap[ 51] = ElmtConfig(eQuadrilateral, 10,  true, false);
            elmMap[ 52] = ElmtConfig(eTriangle,       6, false, false);
            elmMap[ 53] = ElmtConfig(eTriangle,       7, false, false);
            elmMap[ 54] = ElmtConfig(eTriangle,       8, false, false);
            elmMap[ 55] = ElmtConfig(eTriangle,       9, false, false);
            elmMap[ 56] = ElmtConfig(eTriangle,      10, false, false);
            elmMap[ 57] = ElmtConfig(eQuadrilateral,  6, false, false);
            elmMap[ 58] = ElmtConfig(eQuadrilateral,  7, false, false);
            elmMap[ 59] = ElmtConfig(eQuadrilateral,  8, false, false);
            elmMap[ 60] = ElmtConfig(eQuadrilateral,  9, false, false);
            elmMap[ 61] = ElmtConfig(eQuadrilateral, 10, false, false);
            elmMap[ 62] = ElmtConfig(eLine,           6,  true, false);
            elmMap[ 63] = ElmtConfig(eLine,           7,  true, false);
            elmMap[ 64] = ElmtConfig(eLine,           8,  true, false);
            elmMap[ 65] = ElmtConfig(eLine,           9,  true, false);
            elmMap[ 66] = ElmtConfig(eLine,          10,  true, false);
            elmMap[ 71] = ElmtConfig(eTetrahedron,    6,  true,  true);
            elmMap[ 72] = ElmtConfig(eTetrahedron,    7,  true,  true);
            elmMap[ 73] = ElmtConfig(eTetrahedron,    8,  true,  true);
            elmMap[ 74] = ElmtConfig(eTetrahedron,    9,  true,  true);
            elmMap[ 75] = ElmtConfig(eTetrahedron,   10,  true,  true);
            elmMap[ 79] = ElmtConfig(eTetrahedron,    6,  true, false);
            elmMap[ 80] = ElmtConfig(eTetrahedron,    7,  true, false);
            elmMap[ 81] = ElmtConfig(eTetrahedron,    8,  true, false);
            elmMap[ 82] = ElmtConfig(eTetrahedron,    9,  true, false);
            elmMap[ 83] = ElmtConfig(eTetrahedron,   10,  true, false);
            elmMap[ 90] = ElmtConfig(ePrism,          3,  true,  true);
            elmMap[ 91] = ElmtConfig(ePrism,          4,  true,  true);
            elmMap[ 92] = ElmtConfig(eHexahedron,     3,  true,  true);
            elmMap[ 93] = ElmtConfig(eHexahedron,     4,  true,  true);
            elmMap[ 94] = ElmtConfig(eHexahedron,     5,  true,  true);
            elmMap[ 95] = ElmtConfig(eHexahedron,     6,  true,  true);
            elmMap[ 96] = ElmtConfig(eHexahedron,     7,  true,  true);
            elmMap[ 97] = ElmtConfig(eHexahedron,     8,  true,  true);
            elmMap[ 98] = ElmtConfig(eHexahedron,     9,  true,  true);
            elmMap[ 99] = ElmtConfig(eHexahedron,     3,  true, false);
            elmMap[100] = ElmtConfig(eHexahedron,     4,  true, false);
            elmMap[101] = ElmtConfig(eHexahedron,     5,  true, false);
            elmMap[102] = ElmtConfig(eHexahedron,     6,  true, false);
            elmMap[103] = ElmtConfig(eHexahedron,     7,  true, false);
            elmMap[104] = ElmtConfig(eHexahedron,     8,  true, false);
            elmMap[105] = ElmtConfig(eHexahedron,     9,  true, false);
            elmMap[106] = ElmtConfig(ePrism,          5,  true,  true);
            elmMap[107] = ElmtConfig(ePrism,          6,  true,  true);
            elmMap[108] = ElmtConfig(ePrism,          7,  true,  true);
            elmMap[109] = ElmtConfig(ePrism,          8,  true,  true);
            elmMap[110] = ElmtConfig(ePrism,          9,  true,  true);
            elmMap[111] = ElmtConfig(ePrism,          3,  true, false);
            elmMap[112] = ElmtConfig(ePrism,          4,  true, false);
            elmMap[113] = ElmtConfig(ePrism,          5,  true, false);
            elmMap[114] = ElmtConfig(ePrism,          6,  true, false);
            elmMap[115] = ElmtConfig(ePrism,          7,  true, false);
            elmMap[116] = ElmtConfig(ePrism,          8,  true, false);
            elmMap[117] = ElmtConfig(ePrism,          9,  true, false);
        }

        InputGmsh::~InputGmsh()
        {

        }


        /**
         * Gmsh file contains a list of nodes and their coordinates, along with
         * a list of elements and those nodes which define them. We read in and
         * store the list of nodes in #m_node and store the list of elements in
         * #m_element. Each new element is supplied with a list of entries from
         * #m_node which defines the element. Finally some mesh statistics are
         * printed.
         *
         * @param   pFilename           Filename of Gmsh file to read.
         */
        void InputGmsh::Process()
        {
            m->expDim = 0;
            m->spaceDim = 0;
            string line;
            int nVertices = 0;
            int nEntities = 0;
            int nElements = 0;
            int nBoundaryElements = 0;
            int elm_type = 0;
            int prevId = -1;
            map<unsigned int, ElmtConfig>::iterator it;

            cerr << "Start reading InputGmsh..." << endl;
            while (!mshFile.eof())
            {
                getline(mshFile, line);
                stringstream s(line);
                string word;
                s >> word;

                // Process nodes.
                if (word == "$Nodes")
                {
                    getline(mshFile, line);
                    stringstream s(line);
                    s >> nVertices;
                    int id = 0;
                    for (int i = 0; i < nVertices; ++i)
                    {
                        getline(mshFile, line);
                        stringstream st(line);
                        double x = 0, y = 0, z = 0;
                        st >> id >> x >> y >> z;

                        if ((x * x) > 0.000001 && m->spaceDim < 1)
                        {
                            m->spaceDim = 1;
                        }
                        if ((y * y) > 0.000001 && m->spaceDim < 2)
                        {
                            m->spaceDim = 2;
                        }
                        if ((z * z) > 0.000001 && m->spaceDim < 3)
                        {
                            m->spaceDim = 3;
                        }
                        
                        id -= 1; // counter starts at 0
                        
                        if (id-prevId != 1)
                        {
                            cerr << "Gmsh vertex ids should be contiguous" << endl;
                            abort();
                        }
                        prevId = id;
                        m->node.push_back(boost::shared_ptr<Node>(new Node(id, x, y, z)));
                    }
                }
                // Process elements
                else if (word == "$Elements")
                {
                    int zeroDid = 0, oneDid = 0, twoDid = 0, threeDid = 0;
                    getline(mshFile, line);
                    stringstream s(line);
                    s >> nEntities;
                    for (int i = 0; i < nEntities; ++i)
                    {
                        getline(mshFile, line);
                        stringstream st(line);
                        int id = 0, num_tag = 0, num_nodes = 0;

                        st >> id >> elm_type >> num_tag;
                        id -= 1; // counter starts at 0

                        it = elmMap.find(elm_type);
                        if (it == elmMap.end())
                        {
                            cerr << "Error: element type " << elm_type
                                 << " not supported" << endl;
                            abort();
                        }

                        // Read element tags
                        vector<int> tags;
                        for (int j = 0; j < num_tag; ++j)
                        {
                            int tag = 0;
                            st >> tag;
                            tags.push_back(tag);
                        }
                        tags.push_back(elm_type);
                        
                        // Read element node list
                        vector<NodeSharedPtr> nodeList;
                        num_nodes = GetNnodes(elm_type);
                        for (int k = 0; k < num_nodes; ++k)
                        {
                            int node = 0;
                            st >> node;
                            node -= 1; // counter starts at 0
                            nodeList.push_back(m->node[node]);
                        }

                        // Prism nodes need re-ordering for Nektar++.
                        if (it->second.e == ePrism)
                        {
                            // Mirror first in uv plane to swap around
                            // triangular faces
                            swap(nodeList[0], nodeList[3]);
                            swap(nodeList[1], nodeList[4]);
                            swap(nodeList[2], nodeList[5]);
                            // Reorder base points so that face/vertices map
                            // correctly.
                            swap(nodeList[4], nodeList[2]);
                            
                            if (it->second.order == 2)
                            {
                                vector<NodeSharedPtr> nodemap(18);
                                
                                // Vertices remain unchanged.
                                nodemap[ 0] = nodeList[ 0];
                                nodemap[ 1] = nodeList[ 1];
                                nodemap[ 2] = nodeList[ 2];
                                nodemap[ 3] = nodeList[ 3];
                                nodemap[ 4] = nodeList[ 4];
                                nodemap[ 5] = nodeList[ 5];
                                // Reorder edge nodes: first mirror in uv
                                // plane and then place in Nektar++ ordering.
                                nodemap[ 6] = nodeList[12];
                                nodemap[ 7] = nodeList[10];
                                nodemap[ 8] = nodeList[ 6];
                                nodemap[ 9] = nodeList[ 8];
                                nodemap[10] = nodeList[13];
                                nodemap[11] = nodeList[14];
                                nodemap[12] = nodeList[ 9];
                                nodemap[13] = nodeList[ 7];
                                nodemap[14] = nodeList[11];
                                // Face vertices remain unchanged.
                                nodemap[15] = nodeList[15];
                                nodemap[16] = nodeList[16];
                                nodemap[17] = nodeList[17];
                                
                                nodeList = nodemap;
                            }
                            else if (it->second.order > 2)
                            {
                                cerr << "Error: gmsh prisms only supported up "
                                     << "to second order." << endl;
                                abort();
                            }
                        }
                        
                        // Create element
                        ElementSharedPtr E = GetElementFactory().
                            CreateInstance(it->second.e,it->second,nodeList,tags);

                        // Determine mesh expansion dimension
                        if (E->GetDim() > m->expDim) {
                            m->expDim = E->GetDim();
                        }
                        m->element[E->GetDim()].push_back(E);
                    }
                }
            }
            mshFile.close();

            // Process rest of mesh.
            ProcessVertices  ();
            ProcessEdges     ();
            ProcessFaces     ();
            ProcessElements  ();
            ProcessComposites();
        }

        /**
         * For a given msh ID, return the corresponding number of nodes.
         */
        int InputGmsh::GetNnodes(unsigned int InputGmshEntity)
        {
            int nNodes;
            map<unsigned int, ElmtConfig>::iterator it;
            
            it = elmMap.find(InputGmshEntity);
            
            if (it == elmMap.end())
            {
                cerr << "Unknown element type " << InputGmshEntity << endl;
                abort();
            }
            
            switch(it->second.e)
            {
                case ePoint: 
                    nNodes = Point::        GetNumNodes(it->second);
                    break;
                case eLine: 
                    nNodes = Line::         GetNumNodes(it->second);
                    break;
                case eTriangle: 
                    nNodes = Triangle::     GetNumNodes(it->second);
                    break;
                case eQuadrilateral: 
                    nNodes = Quadrilateral::GetNumNodes(it->second);
                    break;
                case eTetrahedron: 
                    nNodes = Tetrahedron::  GetNumNodes(it->second);
                    break;
                case ePrism: 
                    nNodes = Prism::        GetNumNodes(it->second);
                    break;
                case eHexahedron:
                    nNodes = Hexahedron::   GetNumNodes(it->second);
                    break;
                default:
                    cerr << "Unknown element type!" << endl;
                    abort();
                    break;
            }
            
            return nNodes;
        }
    }
}
